From ef986fff38e8b9c0a28194a7bb33d8f5460cd4aa Mon Sep 17 00:00:00 2001
From: Perttu Ahola <celeron55@gmail.com>
Date: Thu, 2 Jan 2014 21:24:44 +0200
Subject: [PATCH 2/8] Sailfish and minimal SDL2 support

---
 include/EDeviceTypes.h             |    3 +
 include/IrrCompileConfig.h         |   10 +-
 source/Irrlicht/CEGLManager.h      |    2 +-
 source/Irrlicht/CIrrDeviceSDL2.cpp | 1084 ++++++++++++++++++++++++++++++++++++
 source/Irrlicht/CIrrDeviceSDL2.h   |  240 ++++++++
 source/Irrlicht/COGLES2Driver.cpp  |   25 +-
 source/Irrlicht/COGLES2Driver.h    |    5 +-
 source/Irrlicht/Irrlicht.cpp       |    9 +
 source/Irrlicht/Makefile           |    2 +-
 9 files changed, 1367 insertions(+), 13 deletions(-)
 create mode 100644 source/Irrlicht/CIrrDeviceSDL2.cpp
 create mode 100644 source/Irrlicht/CIrrDeviceSDL2.h

diff --git a/include/EDeviceTypes.h b/include/EDeviceTypes.h
index e15a0bf..2331ab0 100644
--- a/include/EDeviceTypes.h
+++ b/include/EDeviceTypes.h
@@ -62,6 +62,9 @@ namespace irr
 		Does not need X11 or other graphical subsystems.
 		May support hw-acceleration via OpenGL-ES */
 		EIDT_ANDROID,		
+
+		//! A device which uses Simple DirectMedia Layer version 2
+		EIDT_SDL2,
 	};
 
 } // end namespace irr
diff --git a/include/IrrCompileConfig.h b/include/IrrCompileConfig.h
index 6d415af..ad399d1 100644
--- a/include/IrrCompileConfig.h
+++ b/include/IrrCompileConfig.h
@@ -113,6 +113,14 @@
 #define _IRR_COMPILE_ANDROID_ASSET_READER_
 #endif
 
+#if defined(_IRR_SAILFISH_PLATFORM_)
+#define _IRR_POSIX_API_
+#define NO_IRR_COMPILE_WITH_OGLES1_
+#define _IRR_COMPILE_WITH_OGLES2_
+#define _IRR_COMPILE_WITH_SDL2_DEVICE_
+#define NO_IRR_COMPILE_WITH_X11_
+#endif
+
 #if defined(__SVR4) && defined(__sun)
 #define _IRR_SOLARIS_PLATFORM_
 #if defined(__sparc)
@@ -120,7 +128,7 @@
 #endif
 #endif
 
-#if !defined(_IRR_WINDOWS_API_) && !defined(_IRR_OSX_PLATFORM_) && !defined(_IRR_ANDROID_PLATFORM_)
+#if !defined(_IRR_WINDOWS_API_) && !defined(_IRR_OSX_PLATFORM_) && !defined(_IRR_ANDROID_PLATFORM_) && !defined(_IRR_SAILFISH_PLATFORM_)
 #ifndef _IRR_SOLARIS_PLATFORM_
 #define _IRR_LINUX_PLATFORM_
 #endif
diff --git a/source/Irrlicht/CEGLManager.h b/source/Irrlicht/CEGLManager.h
index c393633..234be90 100755
--- a/source/Irrlicht/CEGLManager.h
+++ b/source/Irrlicht/CEGLManager.h
@@ -9,7 +9,7 @@
 
 #ifdef _IRR_COMPILE_WITH_EGL_MANAGER_
 
-#if defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_SAILFISH_PLATFORM_)
 #include <EGL/egl.h>
 #else
 #include <GLES/egl.h>
diff --git a/source/Irrlicht/CIrrDeviceSDL2.cpp b/source/Irrlicht/CIrrDeviceSDL2.cpp
new file mode 100644
index 0000000..2255b4e
--- /dev/null
+++ b/source/Irrlicht/CIrrDeviceSDL2.cpp
@@ -0,0 +1,1084 @@
+// Copyright (C) 2002-2012 Nikolaus Gebhardt
+// This file is part of the "Irrlicht Engine".
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+
+#include "IrrCompileConfig.h"
+
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+
+#include "CIrrDeviceSDL2.h"
+#include "IEventReceiver.h"
+#include "irrList.h"
+#include "os.h"
+#include "CTimer.h"
+#include "irrString.h"
+#include "Keycodes.h"
+#include "COSOperator.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include "SIrrCreationParameters.h"
+#include <SDL2/SDL_syswm.h>
+#include <SDL2/SDL_video.h>
+
+#include "CEGLManager.h" // Sailfish/c55
+#include <wayland-egl.h>
+
+namespace irr
+{
+	namespace video
+	{
+
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
+		IVideoDriver* createDirectX8Driver(const irr::SIrrlichtCreationParameters& params,
+			io::IFileSystem* io, HWND window);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
+		IVideoDriver* createDirectX9Driver(const irr::SIrrlichtCreationParameters& params,
+			io::IFileSystem* io, HWND window);
+		#endif
+
+		#ifdef _IRR_COMPILE_WITH_OPENGL_
+		IVideoDriver* createOpenGLDriver(const SIrrlichtCreationParameters& params,
+				io::IFileSystem* io, CIrrDeviceSDL2* device);
+		#endif
+
+        #ifdef _IRR_COMPILE_WITH_OGLES2_ 	 
+        //IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, video::SExposedVideoData& data, io::IFileSystem* io);
+        IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params, io::IFileSystem* io, IContextManager* contextManager);
+        #endif
+	} // end namespace video
+
+} // end namespace irr
+
+
+namespace irr
+{
+
+//! constructor
+CIrrDeviceSDL2::CIrrDeviceSDL2(const SIrrlichtCreationParameters& param)
+	: CIrrDeviceStub(param),
+	Sdl2Window((SDL_Window*)param.WindowId), SDL_Flags(SDL_WINDOW_SHOWN),
+	MouseX(0), MouseY(0), MouseButtonStates(0),
+	Width(param.WindowSize.Width), Height(param.WindowSize.Height),
+	Resizable(false), WindowHasFocus(false), WindowMinimized(false)
+{
+	#ifdef _DEBUG
+	setDebugName("CIrrDeviceSDL2");
+	#endif
+
+	// Initialize SDL... Timer for sleep, video for the obvious, and
+	// noparachute prevents SDL from catching fatal errors.
+	if (SDL_Init( SDL_INIT_TIMER|SDL_INIT_VIDEO|
+#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+				SDL_INIT_JOYSTICK|
+#endif
+				SDL_INIT_NOPARACHUTE ) < 0)
+	{
+		os::Printer::log( "Unable to initialize SDL!", SDL_GetError());
+		Close = true;
+	}
+
+/*#if defined(_IRR_WINDOWS_)
+	SDL_putenv("SDL_VIDEODRIVER=directx");
+#elif defined(_IRR_OSX_PLATFORM_)
+	SDL_putenv("SDL_VIDEODRIVER=Quartz");
+#else
+	SDL_putenv("SDL_VIDEODRIVER=x11");
+#endif*/
+//	SDL_putenv("SDL_WINDOWID=");
+
+	SDL_VERSION(&Info.version);
+
+	core::stringc sdlversion = "SDL Version ";
+	sdlversion += Info.version.major;
+	sdlversion += ".";
+	sdlversion += Info.version.minor;
+	sdlversion += ".";
+	sdlversion += Info.version.patch;
+
+	Operator = new COSOperator(sdlversion);
+	os::Printer::log(sdlversion.c_str(), ELL_INFORMATION);
+
+	os::Printer::log((core::stringc("SDL2: Number of displays: ")+
+			core::stringc(SDL_GetNumVideoDisplays())).c_str(), ELL_INFORMATION);
+		
+	for(int i=0; i<SDL_GetNumVideoDisplays(); i++){
+		for(int j=0; j<SDL_GetNumDisplayModes(i); j++){
+			SDL_DisplayMode m;
+			SDL_GetDisplayMode(i, j, &m);
+			os::Printer::log((core::stringc("Display ")+core::stringc(i)+
+					core::stringc(" mode ")+core::stringc(j)+
+					core::stringc(": ")+core::stringc(m.w)+
+					core::stringc("x")+core::stringc(m.h)).c_str(), ELL_INFORMATION);
+		}
+	}
+
+	// create keymap
+	createKeyMap();
+
+	if ( CreationParams.Fullscreen )
+		//SDL_Flags |= SDL_WINDOW_FULLSCREEN;
+		SDL_Flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;
+	if (CreationParams.DriverType == video::EDT_OPENGL)
+		SDL_Flags |= SDL_WINDOW_OPENGL;
+
+	// create window
+	if (CreationParams.DriverType != video::EDT_NULL)
+	{
+		// create the window, only if we do not use the null device
+		createWindow();
+	}
+
+	// create cursor control
+	CursorControl = new CCursorControl(this);
+
+	// create driver
+	createDriver();
+
+	if (VideoDriver)
+		createGUIAndScene();
+}
+
+
+//! destructor
+CIrrDeviceSDL2::~CIrrDeviceSDL2()
+{
+#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+	const u32 numJoysticks = Joysticks.size();
+	for (u32 i=0; i<numJoysticks; ++i)
+		SDL_JoystickClose(Joysticks[i]);
+#endif
+	SDL_Quit();
+}
+
+static SDL_Window* createSDL2Window(int w, int h, Uint32 flags)
+{
+	return SDL_CreateWindow("Irrlicht/SDL2", SDL_WINDOWPOS_UNDEFINED,
+			SDL_WINDOWPOS_UNDEFINED, w, h, flags);
+}
+
+bool CIrrDeviceSDL2::createWindow()
+{
+	if ( Close )
+		return false;
+
+	if (CreationParams.DriverType == video::EDT_OPENGL)
+	{
+		if (CreationParams.Bits==16)
+		{
+			SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 4 );
+			SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 4 );
+			SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 4 );
+			SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel?1:0 );
+		}
+		else
+		{
+			SDL_GL_SetAttribute( SDL_GL_RED_SIZE, 8 );
+			SDL_GL_SetAttribute( SDL_GL_GREEN_SIZE, 8 );
+			SDL_GL_SetAttribute( SDL_GL_BLUE_SIZE, 8 );
+			SDL_GL_SetAttribute( SDL_GL_ALPHA_SIZE, CreationParams.WithAlphaChannel?8:0 );
+		}
+		SDL_GL_SetAttribute( SDL_GL_DEPTH_SIZE, CreationParams.ZBufferBits);
+		if (CreationParams.Doublebuffer)
+			SDL_GL_SetAttribute( SDL_GL_DOUBLEBUFFER, 1 );
+		if (CreationParams.Stereobuffer)
+			SDL_GL_SetAttribute( SDL_GL_STEREO, 1 );
+		if (CreationParams.AntiAlias>1)
+		{
+			SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 1 );
+			SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias );
+		}
+		if ( !Sdl2Window )
+			Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+		if ( !Sdl2Window && CreationParams.AntiAlias>1)
+		{
+			while (--CreationParams.AntiAlias>1)
+			{
+				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, CreationParams.AntiAlias );
+				Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+				if (Sdl2Window)
+					break;
+			}
+			if ( !Sdl2Window )
+			{
+				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLEBUFFERS, 0 );
+				SDL_GL_SetAttribute( SDL_GL_MULTISAMPLESAMPLES, 0 );
+				Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+				if (Sdl2Window)
+					os::Printer::log("AntiAliasing disabled due to lack of support!" );
+			}
+		}
+	}
+	else if ( !Sdl2Window )
+		Sdl2Window = createSDL2Window( Width, Height, SDL_Flags );
+
+	if ( !Sdl2Window )
+	{
+		os::Printer::log( "Could not initialize display!" );
+		return false;
+	}
+
+	SDL_GetWindowWMInfo(Sdl2Window, &Info);
+	return true;
+}
+
+
+//! create the driver
+void CIrrDeviceSDL2::createDriver()
+{
+	os::Printer::log("CIrrDeviceSDL2::createDriver()", ELL_INFORMATION);
+	switch(CreationParams.DriverType)
+	{
+	case video::EDT_DIRECT3D8:
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_8_
+
+		VideoDriver = video::createDirectX8Driver(CreationParams, FileSystem, HWnd);
+		if (!VideoDriver)
+		{
+			os::Printer::log("Could not create DIRECT3D8 Driver.", ELL_ERROR);
+		}
+		#else
+		os::Printer::log("DIRECT3D8 Driver was not compiled into this dll. Try another one.", ELL_ERROR);
+		#endif // _IRR_COMPILE_WITH_DIRECT3D_8_
+
+		break;
+
+	case video::EDT_DIRECT3D9:
+		#ifdef _IRR_COMPILE_WITH_DIRECT3D_9_
+
+		VideoDriver = video::createDirectX9Driver(CreationParams, FileSystem, HWnd);
+		if (!VideoDriver)
+		{
+			os::Printer::log("Could not create DIRECT3D9 Driver.", ELL_ERROR);
+		}
+		#else
+		os::Printer::log("DIRECT3D9 Driver was not compiled into this dll. Try another one.", ELL_ERROR);
+		#endif // _IRR_COMPILE_WITH_DIRECT3D_9_
+
+		break;
+
+	case video::EDT_SOFTWARE:
+		#ifdef _IRR_COMPILE_WITH_SOFTWARE_
+		VideoDriver = video::createSoftwareDriver(CreationParams.WindowSize, CreationParams.Fullscreen, FileSystem, this);
+		#else
+		os::Printer::log("No Software driver support compiled in.", ELL_ERROR);
+		#endif
+		break;
+
+	case video::EDT_BURNINGSVIDEO:
+		#ifdef _IRR_COMPILE_WITH_BURNINGSVIDEO_
+		VideoDriver = video::createBurningVideoDriver(CreationParams, FileSystem, this);
+		#else
+		os::Printer::log("Burning's video driver was not compiled in.", ELL_ERROR);
+		#endif
+		break;
+
+	case video::EDT_OPENGL:
+		#ifdef _IRR_COMPILE_WITH_OPENGL_
+		VideoDriver = video::createOpenGLDriver(CreationParams, FileSystem, this);
+		#else
+		os::Printer::log("No OpenGL support compiled in.", ELL_ERROR);
+		#endif
+		break;
+
+    case video::EDT_OGLES2: 	 
+        #ifdef _IRR_COMPILE_WITH_OGLES2_
+        {
+            video::SExposedVideoData data;
+			switch(Info.subsystem){
+			case SDL_SYSWM_X11:
+				os::Printer::log("Subsystem for sdl2/ogles2: X11", ELL_INFORMATION);
+			#if defined(SDL_VIDEO_DRIVER_X11)
+				data.OpenGLLinux.X11Window = Info.info.x11.window; // Should be wl_egl_window
+				data.OpenGLLinux.X11Display = Info.info.x11.display;
+			#else
+				os::Printer::log("Subsystem for sdl2/ogles2: X11: not supported", ELL_ERROR);
+			#endif
+				break;
+			case SDL_SYSWM_WAYLAND: {
+				os::Printer::log("Subsystem for sdl2/ogles2: Wayland", ELL_INFORMATION);
+			#if defined(SDL_VIDEO_DRIVER_WAYLAND)
+				void *egl_window = wl_egl_window_create(Info.info.wl.surface, Width, Height);
+				if(!egl_window){
+					os::Printer::log("Wayland: Failed to create EGL window", ELL_ERROR);
+					Close = true;
+					return;
+				}
+				//data.OpenGLLinux.X11Window = (long unsigned int)Info.info.wl.surface; // Should be wl_egl_window
+				data.OpenGLLinux.X11Window = (long unsigned int)egl_window;
+				data.OpenGLLinux.X11Display = Info.info.wl.display;
+			#else
+				os::Printer::log("Subsystem for sdl2/ogles2: Wayland: not supported", ELL_ERROR);
+			#endif
+				break; }
+			case SDL_SYSWM_UNKNOWN:
+				os::Printer::log("Subsystem for sdl2/ogles2: SDL reports unknown: "
+						"not supported", ELL_ERROR);
+				break;
+			default:
+				os::Printer::log("Subsystem for sdl2/ogles2: Unimplemented",
+						ELL_INFORMATION);
+			}
+            ContextManager = new video::CEGLManager();
+			ContextManager->initialize(CreationParams, data);
+            VideoDriver = video::createOGLES2Driver(CreationParams, FileSystem, ContextManager);
+        }
+        #else
+        os::Printer::log("No OpenGL-ES2 support compiled in.", ELL_ERROR); 	 
+        #endif 	 
+        break;
+
+	case video::EDT_NULL:
+		VideoDriver = video::createNullDriver(FileSystem, CreationParams.WindowSize);
+		break;
+
+	default:
+		os::Printer::log("Unable to create video driver of unknown type.", ELL_ERROR);
+		break;
+	}
+}
+
+
+//! runs the device. Returns false if device wants to be deleted
+bool CIrrDeviceSDL2::run()
+{
+	os::Timer::tick();
+
+	SEvent irrevent;
+	SDL_Event SDL_event;
+
+	while ( !Close && SDL_PollEvent( &SDL_event ) )
+	{
+		switch ( SDL_event.type )
+		{
+		case SDL_FINGERDOWN:
+		case SDL_FINGERUP:
+		case SDL_FINGERMOTION:
+			{
+				// TODO: Implement properly
+				irrevent.EventType = EET_MULTI_TOUCH_EVENT;
+				irrevent.MultiTouchInput.clear();
+				bool Touched = false;
+				switch (SDL_event.type)
+				{
+				case SDL_FINGERDOWN:
+					irrevent.MultiTouchInput.Event = EMTIE_PRESSED_DOWN;
+					Touched = true;
+					break;
+				case SDL_FINGERUP:
+					irrevent.MultiTouchInput.Event = EMTIE_LEFT_UP;
+					break;
+				case SDL_FINGERMOTION:
+					irrevent.MultiTouchInput.Event = EMTIE_MOVED;
+					Touched = true;
+					break;
+				default:
+					break;
+				}
+				int i = 0;
+				irrevent.MultiTouchInput.PrevX[i] = 0; // TODO
+				irrevent.MultiTouchInput.PrevY[i] = 0; // TODO
+				irrevent.MultiTouchInput.X[i] = SDL_event.tfinger.x;
+				irrevent.MultiTouchInput.Y[i] = SDL_event.tfinger.y;
+				irrevent.MultiTouchInput.Touched[i] = Touched;
+				postEventFromUser(irrevent);
+
+				irrevent = SEvent(); // clear
+				irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+				switch (SDL_event.type)
+				{
+				case SDL_FINGERDOWN:
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_PRESSED_DOWN;
+					irrevent.MouseInput.ButtonStates = EMBSM_LEFT;
+					break;
+				case SDL_FINGERUP:
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_LEFT_UP;
+					break;
+				case SDL_FINGERMOTION:
+					irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
+					irrevent.MouseInput.ButtonStates = EMBSM_LEFT;
+					break;
+				default:
+					break;
+				}
+				MouseX = irrevent.MouseInput.X = SDL_event.tfinger.x;
+				MouseY = irrevent.MouseInput.Y = SDL_event.tfinger.y;
+				postEventFromUser(irrevent);
+			}
+
+			SDL_StartTextInput(); // Test
+			break;
+
+		case SDL_MOUSEMOTION:
+			irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+			irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
+			MouseX = irrevent.MouseInput.X = SDL_event.motion.x;
+			MouseY = irrevent.MouseInput.Y = SDL_event.motion.y;
+			irrevent.MouseInput.ButtonStates = MouseButtonStates;
+
+			postEventFromUser(irrevent);
+			break;
+
+		case SDL_MOUSEBUTTONDOWN:
+		case SDL_MOUSEBUTTONUP:
+
+			irrevent.EventType = irr::EET_MOUSE_INPUT_EVENT;
+			irrevent.MouseInput.X = SDL_event.button.x;
+			irrevent.MouseInput.Y = SDL_event.button.y;
+
+			irrevent.MouseInput.Event = irr::EMIE_MOUSE_MOVED;
+
+			switch(SDL_event.button.button)
+			{
+			case SDL_BUTTON_LEFT:
+				if (SDL_event.type == SDL_MOUSEBUTTONDOWN)
+				{
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_PRESSED_DOWN;
+					MouseButtonStates |= irr::EMBSM_LEFT;
+				}
+				else
+				{
+					irrevent.MouseInput.Event = irr::EMIE_LMOUSE_LEFT_UP;
+					MouseButtonStates &= !irr::EMBSM_LEFT;
+				}
+				break;
+
+			case SDL_BUTTON_RIGHT:
+				if (SDL_event.type == SDL_MOUSEBUTTONDOWN)
+				{
+					irrevent.MouseInput.Event = irr::EMIE_RMOUSE_PRESSED_DOWN;
+					MouseButtonStates |= irr::EMBSM_RIGHT;
+				}
+				else
+				{
+					irrevent.MouseInput.Event = irr::EMIE_RMOUSE_LEFT_UP;
+					MouseButtonStates &= !irr::EMBSM_RIGHT;
+				}
+				break;
+
+			case SDL_BUTTON_MIDDLE:
+				if (SDL_event.type == SDL_MOUSEBUTTONDOWN)
+				{
+					irrevent.MouseInput.Event = irr::EMIE_MMOUSE_PRESSED_DOWN;
+					MouseButtonStates |= irr::EMBSM_MIDDLE;
+				}
+				else
+				{
+					irrevent.MouseInput.Event = irr::EMIE_MMOUSE_LEFT_UP;
+					MouseButtonStates &= !irr::EMBSM_MIDDLE;
+				}
+				break;
+
+			/* TODO: Move to SDL_MOUSEWHEEL events
+			case SDL_BUTTON_WHEELUP:
+				irrevent.MouseInput.Event = irr::EMIE_MOUSE_WHEEL;
+				irrevent.MouseInput.Wheel = 1.0f;
+				break;
+
+			case SDL_BUTTON_WHEELDOWN:
+				irrevent.MouseInput.Event = irr::EMIE_MOUSE_WHEEL;
+				irrevent.MouseInput.Wheel = -1.0f;
+				break;*/
+			}
+
+			irrevent.MouseInput.ButtonStates = MouseButtonStates;
+
+			if (irrevent.MouseInput.Event != irr::EMIE_MOUSE_MOVED)
+			{
+				postEventFromUser(irrevent);
+
+				if ( irrevent.MouseInput.Event >= EMIE_LMOUSE_PRESSED_DOWN && irrevent.MouseInput.Event <= EMIE_MMOUSE_PRESSED_DOWN )
+				{
+					u32 clicks = checkSuccessiveClicks(irrevent.MouseInput.X, irrevent.MouseInput.Y, irrevent.MouseInput.Event);
+					if ( clicks == 2 )
+					{
+						irrevent.MouseInput.Event = (EMOUSE_INPUT_EVENT)(EMIE_LMOUSE_DOUBLE_CLICK + irrevent.MouseInput.Event-EMIE_LMOUSE_PRESSED_DOWN);
+						postEventFromUser(irrevent);
+					}
+					else if ( clicks == 3 )
+					{
+						irrevent.MouseInput.Event = (EMOUSE_INPUT_EVENT)(EMIE_LMOUSE_TRIPLE_CLICK + irrevent.MouseInput.Event-EMIE_LMOUSE_PRESSED_DOWN);
+						postEventFromUser(irrevent);
+					}
+				}
+			}
+			break;
+
+		case SDL_KEYDOWN:
+		case SDL_KEYUP:
+			{
+				SKeyMap mp;
+				mp.SDLKey = SDL_event.key.keysym.sym;
+				s32 idx = KeyMap.binary_search(mp);
+
+				EKEY_CODE key;
+				if (idx == -1)
+					key = (EKEY_CODE)0;
+				else
+					key = (EKEY_CODE)KeyMap[idx].Win32Key;
+
+#ifdef _IRR_WINDOWS_API_
+				// handle alt+f4 in Windows, because SDL seems not to
+				if ( (SDL_event.key.keysym.mod & KMOD_LALT) && key == KEY_F4)
+				{
+					Close = true;
+					break;
+				}
+#endif
+				irrevent.EventType = irr::EET_KEY_INPUT_EVENT;
+				irrevent.KeyInput.Char = SDL_event.key.keysym.unicode;
+				irrevent.KeyInput.Key = key;
+				irrevent.KeyInput.PressedDown = (SDL_event.type == SDL_KEYDOWN);
+				irrevent.KeyInput.Shift = (SDL_event.key.keysym.mod & KMOD_SHIFT) != 0;
+				irrevent.KeyInput.Control = (SDL_event.key.keysym.mod & KMOD_CTRL ) != 0;
+				postEventFromUser(irrevent);
+			}
+			break;
+
+		case SDL_QUIT:
+			Close = true;
+			break;
+
+		case SDL_WINDOWEVENT:
+			switch (SDL_event.window.event) {
+			case SDL_WINDOWEVENT_SHOWN:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_HIDDEN:
+				break;
+			case SDL_WINDOWEVENT_EXPOSED:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_MOVED:
+				break;
+			case SDL_WINDOWEVENT_RESIZED:
+				// NOTE: Can be other window
+				Width = SDL_event.window.data1;
+				Height = SDL_event.window.data2;
+				// TODO: Is this needed?
+				//Sdl2Window = createSDL2Window( Width, Height, 0, SDL_Flags );
+				if (VideoDriver)
+					VideoDriver->OnResize(core::dimension2d<u32>(Width, Height));
+				break;
+			case SDL_WINDOWEVENT_MINIMIZED:
+				WindowMinimized = true;
+				break;
+			case SDL_WINDOWEVENT_MAXIMIZED:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_RESTORED:
+				WindowMinimized = false;
+				break;
+			case SDL_WINDOWEVENT_ENTER:
+				break;
+			case SDL_WINDOWEVENT_LEAVE:
+				break;
+			case SDL_WINDOWEVENT_FOCUS_GAINED:
+				WindowHasFocus = true;
+				break;
+			case SDL_WINDOWEVENT_FOCUS_LOST:
+				WindowHasFocus = false;
+				break;
+			case SDL_WINDOWEVENT_CLOSE:
+				break;
+			default:
+				break;
+			}
+			break;
+
+		case SDL_USEREVENT:
+			irrevent.EventType = irr::EET_USER_EVENT;
+			irrevent.UserEvent.UserData1 = *(reinterpret_cast<s32*>(&SDL_event.user.data1));
+			irrevent.UserEvent.UserData2 = *(reinterpret_cast<s32*>(&SDL_event.user.data2));
+
+			postEventFromUser(irrevent);
+			break;
+
+		default:
+			break;
+		} // end switch
+
+	} // end while
+
+#if 0 && defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+	// TODO: Check if the multiple open/close calls are too expensive, then
+	// open/close in the constructor/destructor instead
+
+	// update joystick states manually
+	SDL_JoystickUpdate();
+	// we'll always send joystick input events...
+	SEvent joyevent;
+	joyevent.EventType = EET_JOYSTICK_INPUT_EVENT;
+	for (u32 i=0; i<Joysticks.size(); ++i)
+	{
+		SDL_Joystick* joystick = Joysticks[i];
+		if (joystick)
+		{
+			int j;
+			// query all buttons
+			const int numButtons = core::min_(SDL_JoystickNumButtons(joystick), 32);
+			joyevent.JoystickEvent.ButtonStates=0;
+			for (j=0; j<numButtons; ++j)
+				joyevent.JoystickEvent.ButtonStates |= (SDL_JoystickGetButton(joystick, j)<<j);
+
+			// query all axes, already in correct range
+			const int numAxes = core::min_(SDL_JoystickNumAxes(joystick), SEvent::SJoystickEvent::NUMBER_OF_AXES);
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_X]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Y]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_Z]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_R]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_U]=0;
+			joyevent.JoystickEvent.Axis[SEvent::SJoystickEvent::AXIS_V]=0;
+			for (j=0; j<numAxes; ++j)
+				joyevent.JoystickEvent.Axis[j] = SDL_JoystickGetAxis(joystick, j);
+
+			// we can only query one hat, SDL only supports 8 directions
+			if (SDL_JoystickNumHats(joystick)>0)
+			{
+				switch (SDL_JoystickGetHat(joystick, 0))
+				{
+					case SDL_HAT_UP:
+						joyevent.JoystickEvent.POV=0;
+						break;
+					case SDL_HAT_RIGHTUP:
+						joyevent.JoystickEvent.POV=4500;
+						break;
+					case SDL_HAT_RIGHT:
+						joyevent.JoystickEvent.POV=9000;
+						break;
+					case SDL_HAT_RIGHTDOWN:
+						joyevent.JoystickEvent.POV=13500;
+						break;
+					case SDL_HAT_DOWN:
+						joyevent.JoystickEvent.POV=18000;
+						break;
+					case SDL_HAT_LEFTDOWN:
+						joyevent.JoystickEvent.POV=22500;
+						break;
+					case SDL_HAT_LEFT:
+						joyevent.JoystickEvent.POV=27000;
+						break;
+					case SDL_HAT_LEFTUP:
+						joyevent.JoystickEvent.POV=31500;
+						break;
+					case SDL_HAT_CENTERED:
+					default:
+						joyevent.JoystickEvent.POV=65535;
+						break;
+				}
+			}
+			else
+			{
+				joyevent.JoystickEvent.POV=65535;
+			}
+
+			// we map the number directly
+			joyevent.JoystickEvent.Joystick=static_cast<u8>(i);
+			// now post the event
+			postEventFromUser(joyevent);
+			// and close the joystick
+		}
+	}
+#endif
+	return !Close;
+}
+
+//! Activate any joysticks, and generate events for them.
+bool CIrrDeviceSDL2::activateJoysticks(core::array<SJoystickInfo> & joystickInfo)
+{
+#if 0 && defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+	joystickInfo.clear();
+
+	// we can name up to 256 different joysticks
+	const int numJoysticks = core::min_(SDL_NumJoysticks(), 256);
+	Joysticks.reallocate(numJoysticks);
+	joystickInfo.reallocate(numJoysticks);
+
+	int joystick = 0;
+	for (; joystick<numJoysticks; ++joystick)
+	{
+		Joysticks.push_back(SDL_JoystickOpen(joystick));
+		SJoystickInfo info;
+
+		info.Joystick = joystick;
+		info.Axes = SDL_JoystickNumAxes(Joysticks[joystick]);
+		info.Buttons = SDL_JoystickNumButtons(Joysticks[joystick]);
+		info.Name = SDL_JoystickName(joystick);
+		info.PovHat = (SDL_JoystickNumHats(Joysticks[joystick]) > 0)
+						? SJoystickInfo::POV_HAT_PRESENT : SJoystickInfo::POV_HAT_ABSENT;
+
+		joystickInfo.push_back(info);
+	}
+
+	for(joystick = 0; joystick < (int)joystickInfo.size(); ++joystick)
+	{
+		char logString[256];
+		(void)sprintf(logString, "Found joystick %d, %d axes, %d buttons '%s'",
+		joystick, joystickInfo[joystick].Axes,
+		joystickInfo[joystick].Buttons, joystickInfo[joystick].Name.c_str());
+		os::Printer::log(logString, ELL_INFORMATION);
+	}
+
+	return true;
+
+#endif // _IRR_COMPILE_WITH_JOYSTICK_EVENTS_
+
+	return false;
+}
+
+
+
+//! pause execution temporarily
+void CIrrDeviceSDL2::yield()
+{
+	SDL_Delay(0);
+}
+
+
+//! pause execution for a specified time
+void CIrrDeviceSDL2::sleep(u32 timeMs, bool pauseTimer)
+{
+	const bool wasStopped = Timer ? Timer->isStopped() : true;
+	if (pauseTimer && !wasStopped)
+		Timer->stop();
+
+	SDL_Delay(timeMs);
+
+	if (pauseTimer && !wasStopped)
+		Timer->start();
+}
+
+
+//! sets the caption of the window
+void CIrrDeviceSDL2::setWindowCaption(const wchar_t* text)
+{
+	core::stringc textc = text;
+	SDL_SetWindowTitle(Sdl2Window, textc.c_str());
+}
+
+
+//! presents a surface in the client area
+bool CIrrDeviceSDL2::present(video::IImage* surface, void* windowId, core::rect<s32>* srcClip)
+{
+	SDL_Surface *sdlSurface = SDL_CreateRGBSurfaceFrom(
+			surface->lock(), surface->getDimension().Width, surface->getDimension().Height,
+			surface->getBitsPerPixel(), surface->getPitch(),
+			surface->getRedMask(), surface->getGreenMask(), surface->getBlueMask(), surface->getAlphaMask());
+	if (!sdlSurface)
+		return false;
+	//SDL_SetAlpha(sdlSurface, 0, 0);
+	SDL_SetColorKey(sdlSurface, SDL_FALSE, 0);
+	sdlSurface->format->BitsPerPixel=surface->getBitsPerPixel();
+	sdlSurface->format->BytesPerPixel=surface->getBytesPerPixel();
+	if ((surface->getColorFormat()==video::ECF_R8G8B8) ||
+			(surface->getColorFormat()==video::ECF_A8R8G8B8))
+	{
+		sdlSurface->format->Rloss=0;
+		sdlSurface->format->Gloss=0;
+		sdlSurface->format->Bloss=0;
+		sdlSurface->format->Rshift=16;
+		sdlSurface->format->Gshift=8;
+		sdlSurface->format->Bshift=0;
+		if (surface->getColorFormat()==video::ECF_R8G8B8)
+		{
+			sdlSurface->format->Aloss=8;
+			sdlSurface->format->Ashift=32;
+		}
+		else
+		{
+			sdlSurface->format->Aloss=0;
+			sdlSurface->format->Ashift=24;
+		}
+	}
+	else if (surface->getColorFormat()==video::ECF_R5G6B5)
+	{
+		sdlSurface->format->Rloss=3;
+		sdlSurface->format->Gloss=2;
+		sdlSurface->format->Bloss=3;
+		sdlSurface->format->Aloss=8;
+		sdlSurface->format->Rshift=11;
+		sdlSurface->format->Gshift=5;
+		sdlSurface->format->Bshift=0;
+		sdlSurface->format->Ashift=16;
+	}
+	else if (surface->getColorFormat()==video::ECF_A1R5G5B5)
+	{
+		sdlSurface->format->Rloss=3;
+		sdlSurface->format->Gloss=3;
+		sdlSurface->format->Bloss=3;
+		sdlSurface->format->Aloss=7;
+		sdlSurface->format->Rshift=10;
+		sdlSurface->format->Gshift=5;
+		sdlSurface->format->Bshift=0;
+		sdlSurface->format->Ashift=15;
+	}
+
+	SDL_Renderer *renderer = SDL_GetRenderer(Sdl2Window);
+	SDL_Texture *sdlTexture = SDL_CreateTextureFromSurface(renderer, sdlSurface);
+	SDL_RenderCopy(renderer, sdlTexture, NULL, NULL);
+	SDL_RenderPresent(renderer);
+	SDL_DestroyTexture(sdlTexture);
+	SDL_FreeSurface(sdlSurface);
+	surface->unlock();
+	return true;
+}
+
+
+//! notifies the device that it should close itself
+void CIrrDeviceSDL2::closeDevice()
+{
+	Close = true;
+}
+
+
+//! \return Pointer to a list with all video modes supported
+video::IVideoModeList* CIrrDeviceSDL2::getVideoModeList()
+{
+	if (!VideoModeList->getVideoModeCount())
+	{
+		// Bah, let's just hope the user is fine with the default resolution
+		//VideoModeList->addMode(core::dimension2d<u32>(800, 600), 24);
+		// NOTE: SDL2 has SDL_GetNumVideoDisplays/SDL_GetWindowDisplayIndex,
+		// SDL_GetNumDisplayModes, SDL_GetDisplayMode
+	}
+
+	return VideoModeList;
+}
+
+
+//! Sets if the window should be resizable in windowed mode.
+void CIrrDeviceSDL2::setResizable(bool resize)
+{
+	if (resize != Resizable)
+	{
+		if (resize)
+			SDL_Flags |= SDL_WINDOW_RESIZABLE;
+		else
+			SDL_Flags &= ~SDL_WINDOW_RESIZABLE;
+		Sdl2Window = createSDL2Window( 0, 0, SDL_Flags );
+		Resizable = resize;
+	}
+}
+
+
+//! Minimizes window if possible
+void CIrrDeviceSDL2::minimizeWindow()
+{
+	SDL_MinimizeWindow(Sdl2Window);
+}
+
+
+//! Maximize window
+void CIrrDeviceSDL2::maximizeWindow()
+{
+	// do nothing
+}
+
+//! Get the position of this window on screen
+core::position2di CIrrDeviceSDL2::getWindowPosition()
+{
+    return core::position2di(-1, -1);
+}
+
+
+//! Restore original window size
+void CIrrDeviceSDL2::restoreWindow()
+{
+	// do nothing
+}
+
+
+//! returns if window is active. if not, nothing need to be drawn
+bool CIrrDeviceSDL2::isWindowActive() const
+{
+	return (WindowHasFocus && !WindowMinimized);
+}
+
+
+//! returns if window has focus.
+bool CIrrDeviceSDL2::isWindowFocused() const
+{
+	return WindowHasFocus;
+}
+
+
+//! returns if window is minimized.
+bool CIrrDeviceSDL2::isWindowMinimized() const
+{
+	return WindowMinimized;
+}
+
+
+//! Set the current Gamma Value for the Display
+bool CIrrDeviceSDL2::setGammaRamp( f32 red, f32 green, f32 blue, f32 brightness, f32 contrast )
+{
+	/*
+	// todo: Gamma in SDL takes ints, what does Irrlicht use?
+	return (SDL_SetGamma(red, green, blue) != -1);
+	*/
+	return false;
+}
+
+//! Get the current Gamma Value for the Display
+bool CIrrDeviceSDL2::getGammaRamp( f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast )
+{
+/*	brightness = 0.f;
+	contrast = 0.f;
+	return (SDL_GetGamma(&red, &green, &blue) != -1);*/
+	return false;
+}
+
+//! returns color format of the window.
+video::ECOLOR_FORMAT CIrrDeviceSDL2::getColorFormat() const
+{
+	// TODO
+	return CIrrDeviceStub::getColorFormat();
+}
+
+
+void CIrrDeviceSDL2::createKeyMap()
+{
+	// I don't know if this is the best method  to create
+	// the lookuptable, but I'll leave it like that until
+	// I find a better version.
+
+	KeyMap.reallocate(105);
+
+	// buttons missing
+
+	KeyMap.push_back(SKeyMap(SDLK_BACKSPACE, KEY_BACK));
+	KeyMap.push_back(SKeyMap(SDLK_TAB, KEY_TAB));
+	KeyMap.push_back(SKeyMap(SDLK_CLEAR, KEY_CLEAR));
+	KeyMap.push_back(SKeyMap(SDLK_RETURN, KEY_RETURN));
+
+	// combined modifiers missing
+
+	KeyMap.push_back(SKeyMap(SDLK_PAUSE, KEY_PAUSE));
+	KeyMap.push_back(SKeyMap(SDLK_CAPSLOCK, KEY_CAPITAL));
+
+	// asian letter keys missing
+
+	KeyMap.push_back(SKeyMap(SDLK_ESCAPE, KEY_ESCAPE));
+
+	// asian letter keys missing
+
+	KeyMap.push_back(SKeyMap(SDLK_SPACE, KEY_SPACE));
+	KeyMap.push_back(SKeyMap(SDLK_PAGEUP, KEY_PRIOR));
+	KeyMap.push_back(SKeyMap(SDLK_PAGEDOWN, KEY_NEXT));
+	KeyMap.push_back(SKeyMap(SDLK_END, KEY_END));
+	KeyMap.push_back(SKeyMap(SDLK_HOME, KEY_HOME));
+	KeyMap.push_back(SKeyMap(SDLK_LEFT, KEY_LEFT));
+	KeyMap.push_back(SKeyMap(SDLK_UP, KEY_UP));
+	KeyMap.push_back(SKeyMap(SDLK_RIGHT, KEY_RIGHT));
+	KeyMap.push_back(SKeyMap(SDLK_DOWN, KEY_DOWN));
+
+	// select missing
+	KeyMap.push_back(SKeyMap(SDLK_PRINTSCREEN, KEY_PRINT));
+	// execute missing
+	KeyMap.push_back(SKeyMap(SDLK_PRINTSCREEN, KEY_SNAPSHOT));
+
+	KeyMap.push_back(SKeyMap(SDLK_INSERT, KEY_INSERT));
+	KeyMap.push_back(SKeyMap(SDLK_DELETE, KEY_DELETE));
+	KeyMap.push_back(SKeyMap(SDLK_HELP, KEY_HELP));
+
+	KeyMap.push_back(SKeyMap(SDLK_0, KEY_KEY_0));
+	KeyMap.push_back(SKeyMap(SDLK_1, KEY_KEY_1));
+	KeyMap.push_back(SKeyMap(SDLK_2, KEY_KEY_2));
+	KeyMap.push_back(SKeyMap(SDLK_3, KEY_KEY_3));
+	KeyMap.push_back(SKeyMap(SDLK_4, KEY_KEY_4));
+	KeyMap.push_back(SKeyMap(SDLK_5, KEY_KEY_5));
+	KeyMap.push_back(SKeyMap(SDLK_6, KEY_KEY_6));
+	KeyMap.push_back(SKeyMap(SDLK_7, KEY_KEY_7));
+	KeyMap.push_back(SKeyMap(SDLK_8, KEY_KEY_8));
+	KeyMap.push_back(SKeyMap(SDLK_9, KEY_KEY_9));
+
+	KeyMap.push_back(SKeyMap(SDLK_a, KEY_KEY_A));
+	KeyMap.push_back(SKeyMap(SDLK_b, KEY_KEY_B));
+	KeyMap.push_back(SKeyMap(SDLK_c, KEY_KEY_C));
+	KeyMap.push_back(SKeyMap(SDLK_d, KEY_KEY_D));
+	KeyMap.push_back(SKeyMap(SDLK_e, KEY_KEY_E));
+	KeyMap.push_back(SKeyMap(SDLK_f, KEY_KEY_F));
+	KeyMap.push_back(SKeyMap(SDLK_g, KEY_KEY_G));
+	KeyMap.push_back(SKeyMap(SDLK_h, KEY_KEY_H));
+	KeyMap.push_back(SKeyMap(SDLK_i, KEY_KEY_I));
+	KeyMap.push_back(SKeyMap(SDLK_j, KEY_KEY_J));
+	KeyMap.push_back(SKeyMap(SDLK_k, KEY_KEY_K));
+	KeyMap.push_back(SKeyMap(SDLK_l, KEY_KEY_L));
+	KeyMap.push_back(SKeyMap(SDLK_m, KEY_KEY_M));
+	KeyMap.push_back(SKeyMap(SDLK_n, KEY_KEY_N));
+	KeyMap.push_back(SKeyMap(SDLK_o, KEY_KEY_O));
+	KeyMap.push_back(SKeyMap(SDLK_p, KEY_KEY_P));
+	KeyMap.push_back(SKeyMap(SDLK_q, KEY_KEY_Q));
+	KeyMap.push_back(SKeyMap(SDLK_r, KEY_KEY_R));
+	KeyMap.push_back(SKeyMap(SDLK_s, KEY_KEY_S));
+	KeyMap.push_back(SKeyMap(SDLK_t, KEY_KEY_T));
+	KeyMap.push_back(SKeyMap(SDLK_u, KEY_KEY_U));
+	KeyMap.push_back(SKeyMap(SDLK_v, KEY_KEY_V));
+	KeyMap.push_back(SKeyMap(SDLK_w, KEY_KEY_W));
+	KeyMap.push_back(SKeyMap(SDLK_x, KEY_KEY_X));
+	KeyMap.push_back(SKeyMap(SDLK_y, KEY_KEY_Y));
+	KeyMap.push_back(SKeyMap(SDLK_z, KEY_KEY_Z));
+
+	KeyMap.push_back(SKeyMap(SDLK_LGUI, KEY_LWIN));
+	KeyMap.push_back(SKeyMap(SDLK_RGUI, KEY_RWIN));
+	// apps missing
+	KeyMap.push_back(SKeyMap(SDLK_POWER, KEY_SLEEP)); //??
+
+	KeyMap.push_back(SKeyMap(SDLK_KP_0, KEY_NUMPAD0));
+	KeyMap.push_back(SKeyMap(SDLK_KP_1, KEY_NUMPAD1));
+	KeyMap.push_back(SKeyMap(SDLK_KP_2, KEY_NUMPAD2));
+	KeyMap.push_back(SKeyMap(SDLK_KP_3, KEY_NUMPAD3));
+	KeyMap.push_back(SKeyMap(SDLK_KP_4, KEY_NUMPAD4));
+	KeyMap.push_back(SKeyMap(SDLK_KP_5, KEY_NUMPAD5));
+	KeyMap.push_back(SKeyMap(SDLK_KP_6, KEY_NUMPAD6));
+	KeyMap.push_back(SKeyMap(SDLK_KP_7, KEY_NUMPAD7));
+	KeyMap.push_back(SKeyMap(SDLK_KP_8, KEY_NUMPAD8));
+	KeyMap.push_back(SKeyMap(SDLK_KP_9, KEY_NUMPAD9));
+	KeyMap.push_back(SKeyMap(SDLK_KP_MULTIPLY, KEY_MULTIPLY));
+	KeyMap.push_back(SKeyMap(SDLK_KP_PLUS, KEY_ADD));
+//	KeyMap.push_back(SKeyMap(SDLK_KP_, KEY_SEPARATOR));
+	KeyMap.push_back(SKeyMap(SDLK_KP_MINUS, KEY_SUBTRACT));
+	KeyMap.push_back(SKeyMap(SDLK_KP_PERIOD, KEY_DECIMAL));
+	KeyMap.push_back(SKeyMap(SDLK_KP_DIVIDE, KEY_DIVIDE));
+
+	KeyMap.push_back(SKeyMap(SDLK_F1,  KEY_F1));
+	KeyMap.push_back(SKeyMap(SDLK_F2,  KEY_F2));
+	KeyMap.push_back(SKeyMap(SDLK_F3,  KEY_F3));
+	KeyMap.push_back(SKeyMap(SDLK_F4,  KEY_F4));
+	KeyMap.push_back(SKeyMap(SDLK_F5,  KEY_F5));
+	KeyMap.push_back(SKeyMap(SDLK_F6,  KEY_F6));
+	KeyMap.push_back(SKeyMap(SDLK_F7,  KEY_F7));
+	KeyMap.push_back(SKeyMap(SDLK_F8,  KEY_F8));
+	KeyMap.push_back(SKeyMap(SDLK_F9,  KEY_F9));
+	KeyMap.push_back(SKeyMap(SDLK_F10, KEY_F10));
+	KeyMap.push_back(SKeyMap(SDLK_F11, KEY_F11));
+	KeyMap.push_back(SKeyMap(SDLK_F12, KEY_F12));
+	KeyMap.push_back(SKeyMap(SDLK_F13, KEY_F13));
+	KeyMap.push_back(SKeyMap(SDLK_F14, KEY_F14));
+	KeyMap.push_back(SKeyMap(SDLK_F15, KEY_F15));
+	// no higher F-keys
+
+	KeyMap.push_back(SKeyMap(SDLK_NUMLOCKCLEAR, KEY_NUMLOCK));
+	KeyMap.push_back(SKeyMap(SDLK_SCROLLLOCK, KEY_SCROLL));
+	KeyMap.push_back(SKeyMap(SDLK_LSHIFT, KEY_LSHIFT));
+	KeyMap.push_back(SKeyMap(SDLK_RSHIFT, KEY_RSHIFT));
+	KeyMap.push_back(SKeyMap(SDLK_LCTRL,  KEY_LCONTROL));
+	KeyMap.push_back(SKeyMap(SDLK_RCTRL,  KEY_RCONTROL));
+	KeyMap.push_back(SKeyMap(SDLK_LALT,  KEY_LMENU));
+	KeyMap.push_back(SKeyMap(SDLK_RALT,  KEY_RMENU));
+
+	KeyMap.push_back(SKeyMap(SDLK_PLUS,   KEY_PLUS));
+	KeyMap.push_back(SKeyMap(SDLK_COMMA,  KEY_COMMA));
+	KeyMap.push_back(SKeyMap(SDLK_MINUS,  KEY_MINUS));
+	KeyMap.push_back(SKeyMap(SDLK_PERIOD, KEY_PERIOD));
+
+	// some special keys missing
+
+	KeyMap.sort();
+}
+
+} // end namespace irr
+
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+
diff --git a/source/Irrlicht/CIrrDeviceSDL2.h b/source/Irrlicht/CIrrDeviceSDL2.h
new file mode 100644
index 0000000..c7d0672
--- /dev/null
+++ b/source/Irrlicht/CIrrDeviceSDL2.h
@@ -0,0 +1,240 @@
+// Copyright (C) 2002-2012 Nikolaus Gebhardt
+// This file is part of the "Irrlicht Engine".
+// For conditions of distribution and use, see copyright notice in irrlicht.h
+// This device code is based on the original SDL device implementation
+// contributed by Shane Parker (sirshane).
+
+#ifndef __C_IRR_DEVICE_SDL2_H_INCLUDED__
+#define __C_IRR_DEVICE_SDL2_H_INCLUDED__
+
+#include "IrrCompileConfig.h"
+
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+
+#include "IrrlichtDevice.h"
+#include "CIrrDeviceStub.h"
+#include "IImagePresenter.h"
+#include "ICursorControl.h"
+
+#define SDL_MAIN_HANDLED
+#include <SDL2/SDL.h>
+#include <SDL2/SDL_syswm.h>
+
+namespace irr
+{
+
+	class CIrrDeviceSDL2 : public CIrrDeviceStub, video::IImagePresenter
+	{
+	public:
+
+		//! constructor
+		CIrrDeviceSDL2(const SIrrlichtCreationParameters& param);
+
+		//! destructor
+		virtual ~CIrrDeviceSDL2();
+
+		//! runs the device. Returns false if device wants to be deleted
+		virtual bool run();
+
+		//! pause execution temporarily
+		virtual void yield();
+
+		//! pause execution for a specified time
+		virtual void sleep(u32 timeMs, bool pauseTimer);
+
+		//! sets the caption of the window
+		virtual void setWindowCaption(const wchar_t* text);
+
+		//! returns if window is active. if not, nothing need to be drawn
+		virtual bool isWindowActive() const;
+
+		//! returns if window has focus.
+		bool isWindowFocused() const;
+
+		//! returns if window is minimized.
+		bool isWindowMinimized() const;
+
+		//! returns color format of the window.
+		video::ECOLOR_FORMAT getColorFormat() const;
+
+		//! presents a surface in the client area
+		virtual bool present(video::IImage* surface, void* windowId=0, core::rect<s32>* src=0);
+
+		//! notifies the device that it should close itself
+		virtual void closeDevice();
+
+		//! \return Returns a pointer to a list with all video modes supported
+		video::IVideoModeList* getVideoModeList();
+
+		//! Sets if the window should be resizable in windowed mode.
+		virtual void setResizable(bool resize=false);
+
+		//! Minimizes the window.
+		virtual void minimizeWindow();
+
+		//! Maximizes the window.
+		virtual void maximizeWindow();
+
+		//! Restores the window size.
+		virtual void restoreWindow();
+
+		//! Get the position of this window on screen
+		virtual core::position2di getWindowPosition();
+
+		//! Activate any joysticks, and generate events for them.
+		virtual bool activateJoysticks(core::array<SJoystickInfo> & joystickInfo);
+
+		//! Set the current Gamma Value for the Display
+		virtual bool setGammaRamp( f32 red, f32 green, f32 blue, f32 brightness, f32 contrast );
+
+		//! Get the current Gamma Value for the Display
+		virtual bool getGammaRamp( f32 &red, f32 &green, f32 &blue, f32 &brightness, f32 &contrast );
+
+		//! Get the device type
+		virtual E_DEVICE_TYPE getType() const
+		{
+				return EIDT_SDL;
+		}
+
+		//! Implementation of the linux cursor control
+		class CCursorControl : public gui::ICursorControl
+		{
+		public:
+
+			CCursorControl(CIrrDeviceSDL2* dev)
+				: Device(dev), IsVisible(true)
+			{
+			}
+
+			//! Changes the visible state of the mouse cursor.
+			virtual void setVisible(bool visible)
+			{
+				IsVisible = visible;
+				if ( visible )
+					SDL_ShowCursor( SDL_ENABLE );
+				else
+					SDL_ShowCursor( SDL_DISABLE );
+			}
+
+			//! Returns if the cursor is currently visible.
+			virtual bool isVisible() const
+			{
+				return IsVisible;
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(const core::position2d<f32> &pos)
+			{
+				setPosition(pos.X, pos.Y);
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(f32 x, f32 y)
+			{
+				setPosition((s32)(x*Device->Width), (s32)(y*Device->Height));
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(const core::position2d<s32> &pos)
+			{
+				setPosition(pos.X, pos.Y);
+			}
+
+			//! Sets the new position of the cursor.
+			virtual void setPosition(s32 x, s32 y)
+			{
+				// NOTE: There are better ways in SDL2 (relative mode)
+				SDL_WarpMouseInWindow(NULL, x, y);
+			}
+
+			//! Returns the current position of the mouse cursor.
+			virtual const core::position2d<s32>& getPosition()
+			{
+				updateCursorPos();
+				return CursorPos;
+			}
+
+			//! Returns the current position of the mouse cursor.
+			virtual core::position2d<f32> getRelativePosition()
+			{
+				updateCursorPos();
+				return core::position2d<f32>(CursorPos.X / (f32)Device->Width,
+					CursorPos.Y / (f32)Device->Height);
+			}
+
+			virtual void setReferenceRect(core::rect<s32>* rect=0)
+			{
+			}
+
+		private:
+
+			void updateCursorPos()
+			{
+				CursorPos.X = Device->MouseX;
+				CursorPos.Y = Device->MouseY;
+
+				if (CursorPos.X < 0)
+					CursorPos.X = 0;
+				if (CursorPos.X > (s32)Device->Width)
+					CursorPos.X = Device->Width;
+				if (CursorPos.Y < 0)
+					CursorPos.Y = 0;
+				if (CursorPos.Y > (s32)Device->Height)
+					CursorPos.Y = Device->Height;
+			}
+
+			CIrrDeviceSDL2* Device;
+			core::position2d<s32> CursorPos;
+			bool IsVisible;
+		};
+
+	private:
+
+		//! create the driver
+		void createDriver();
+
+		bool createWindow();
+
+		void createKeyMap();
+
+		SDL_Window* Sdl2Window;
+		int SDL_Flags;
+#if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
+		core::array<SDL_Joystick*> Joysticks;
+#endif
+
+		s32 MouseX, MouseY;
+		u32 MouseButtonStates;
+
+		u32 Width, Height;
+
+		bool Resizable;
+		bool WindowHasFocus;
+		bool WindowMinimized;
+
+		struct SKeyMap
+		{
+			SKeyMap() {}
+			SKeyMap(s32 x11, s32 win32)
+				: SDLKey(x11), Win32Key(win32)
+			{
+			}
+
+			s32 SDLKey;
+			s32 Win32Key;
+
+			bool operator<(const SKeyMap& o) const
+			{
+				return SDLKey<o.SDLKey;
+			}
+		};
+
+		core::array<SKeyMap> KeyMap;
+		SDL_SysWMinfo Info;
+	};
+
+} // end namespace irr
+
+#endif // _IRR_COMPILE_WITH_SDL2_DEVICE_
+#endif // __C_IRR_DEVICE_SDL2_H_INCLUDED__
+
diff --git a/source/Irrlicht/COGLES2Driver.cpp b/source/Irrlicht/COGLES2Driver.cpp
index cb5c068..4c8433d 100644
--- a/source/Irrlicht/COGLES2Driver.cpp
+++ b/source/Irrlicht/COGLES2Driver.cpp
@@ -31,6 +31,8 @@
 #endif
 #endif
 
+#include "IContextManager.h"
+
 namespace irr
 {
 namespace video
@@ -38,7 +40,7 @@ namespace video
 
 COGLES2Driver::COGLES2Driver(const SIrrlichtCreationParameters& params,
 			io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
             , IContextManager* contextManager
 #elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
             , CIrrDeviceIPhone* device
@@ -47,7 +49,7 @@ COGLES2Driver::COGLES2Driver(const SIrrlichtCreationParameters& params,
 	BridgeCalls(0), CurrentRenderMode(ERM_NONE), ResetRenderStates(true),
 	Transformation3DChanged(true), AntiAlias(params.AntiAlias),
 	RenderTargetTexture(0), CurrentRendertargetSize(0, 0), ColorFormat(ECF_R8G8B8)
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
     , ContextManager(contextManager)
 #elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
     , Device(device), ViewFramebuffer(0),
@@ -60,7 +62,7 @@ COGLES2Driver::COGLES2Driver(const SIrrlichtCreationParameters& params,
 
     core::dimension2d<u32> WindowSize(0, 0);
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
 	if (!ContextManager)
 		return;
 
@@ -115,7 +117,7 @@ COGLES2Driver::~COGLES2Driver()
 
 	delete BridgeCalls;
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
 	if (ContextManager)
 	{
 		ContextManager->destroyContext();
@@ -231,6 +233,12 @@ COGLES2Driver::~COGLES2Driver()
 		io::IReadFile* FPVSFile = FileSystem->createAndOpenFile(FPVSPath);
 		io::IReadFile* FPFSFile = FileSystem->createAndOpenFile(FPFSPath);
 
+		if(!FPVSFile || !FPVSFile){
+			os::Printer::log((core::stringc()+"Failed to open shader files ["+
+					FPVSPath+"] ["+FPFSPath+"]").c_str(), ELL_ERROR);
+			return;
+		}
+
 		c8* FPVSData = 0;
 		c8* FPFSData = 0;
 
@@ -436,7 +444,7 @@ bool COGLES2Driver::endScene()
 {
 	CNullDriver::endScene();
 
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
     if (ContextManager)
 		ContextManager->swapBuffers();
 #elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
@@ -1858,7 +1866,8 @@ bool COGLES2Driver::endScene()
 		for (s32 i = MaxTextureUnits-1; i>= 0; --i)
 		{
 			const COGLES2Texture* tmpTexture = static_cast<const COGLES2Texture*>(CurrentTexture[i]);
-			GLenum tmpTextureType = (tmpTexture) ? tmpTexture->getOpenGLTextureType() : GL_TEXTURE_2D;
+			//GLenum tmpTextureType = (tmpTexture) ? tmpTexture->getOpenGLTextureType() : GL_TEXTURE_2D;
+			GLenum tmpTextureType = GL_TEXTURE_2D; // ES2 doesn't seem to support all OpenGL texture types (HACK)
 
 			if (CurrentTexture[i])
 				BridgeCalls->setTexture(i, tmpTextureType);
@@ -2902,7 +2911,7 @@ class IContextManager;
 
 IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params,
 		io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
         , IContextManager* contextManager
 #elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
         , CIrrDeviceIPhone* device
@@ -2911,7 +2920,7 @@ IVideoDriver* createOGLES2Driver(const SIrrlichtCreationParameters& params,
 {
 #ifdef _IRR_COMPILE_WITH_OGLES2_
 	return new COGLES2Driver(params, io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
         , contextManager
 #elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
         , device
diff --git a/source/Irrlicht/COGLES2Driver.h b/source/Irrlicht/COGLES2Driver.h
index f40959d..cdeeaeb 100644
--- a/source/Irrlicht/COGLES2Driver.h
+++ b/source/Irrlicht/COGLES2Driver.h
@@ -46,6 +46,7 @@ namespace video
 	class COGLES2Renderer2D;
 	class COGLES2NormalMapRenderer;
 	class COGLES2ParallaxMapRenderer;
+	class IContextManager;
 
 	class COGLES2Driver : public CNullDriver, public IMaterialRendererServices, public COGLES2ExtensionHandler
 	{
@@ -56,7 +57,7 @@ namespace video
 		//! constructor
 		COGLES2Driver(const SIrrlichtCreationParameters& params,
 				io::IFileSystem* io
-#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#if defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
 		, IContextManager* contextManager
 #elif defined(_IRR_COMPILE_WITH_IPHONE_DEVICE_)
 		, CIrrDeviceIPhone* device
@@ -454,7 +455,7 @@ namespace video
 		GLuint ViewFramebuffer;
 		GLuint ViewRenderbuffer;
 		GLuint ViewDepthRenderbuffer;
-#elif defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_)
+#elif defined(_IRR_COMPILE_WITH_X11_DEVICE_) || defined(_IRR_WINDOWS_API_) || defined(_IRR_COMPILE_WITH_ANDROID_DEVICE_) || defined(_IRR_COMPILE_WITH_SDL2_DEVICE_)
 		IContextManager* ContextManager;
 #endif
 	};
diff --git a/source/Irrlicht/Irrlicht.cpp b/source/Irrlicht/Irrlicht.cpp
index e87c764..b10f4d1 100644
--- a/source/Irrlicht/Irrlicht.cpp
+++ b/source/Irrlicht/Irrlicht.cpp
@@ -42,6 +42,10 @@ static const char* const copyright = "Irrlicht Engine (c) 2002-2012 Nikolaus Geb
 #include "CIrrDeviceSDL.h"
 #endif
 
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+#include "CIrrDeviceSDL2.h"
+#endif
+
 #ifdef _IRR_COMPILE_WITH_FB_DEVICE_
 #include "CIrrDeviceFB.h"
 #endif
@@ -110,6 +114,11 @@ namespace irr
 			dev = new CIrrDeviceSDL(params);
 #endif
 
+#ifdef _IRR_COMPILE_WITH_SDL2_DEVICE_
+		if (params.DeviceType == EIDT_SDL2 || (!dev && params.DeviceType == EIDT_BEST))
+			dev = new CIrrDeviceSDL2(params);
+#endif
+
 #ifdef _IRR_COMPILE_WITH_FB_DEVICE_
 		if (params.DeviceType == EIDT_FRAMEBUFFER || (!dev && params.DeviceType == EIDT_BEST))
 			dev = new CIrrDeviceFB(params);
diff --git a/source/Irrlicht/Makefile b/source/Irrlicht/Makefile
index 822e688..656cb26 100644
--- a/source/Irrlicht/Makefile
+++ b/source/Irrlicht/Makefile
@@ -44,7 +44,7 @@ IRRIMAGEOBJ = CColorConverter.o CImage.o CImageLoaderBMP.o CImageLoaderDDS.o CIm
 IRRVIDEOOBJ = CVideoModeList.o CFPSCounter.o $(IRRDRVROBJ) $(IRRIMAGEOBJ)
 IRRSWRENDEROBJ = CSoftwareDriver.o CSoftwareTexture.o CTRFlat.o CTRFlatWire.o CTRGouraud.o CTRGouraudWire.o CTRNormalMap.o CTRStencilShadow.o CTRTextureFlat.o CTRTextureFlatWire.o CTRTextureGouraud.o CTRTextureGouraudAdd.o CTRTextureGouraudNoZ.o CTRTextureGouraudWire.o CZBuffer.o CTRTextureGouraudVertexAlpha2.o CTRTextureGouraudNoZ2.o CTRTextureLightMap2_M2.o CTRTextureLightMap2_M4.o CTRTextureLightMap2_M1.o CSoftwareDriver2.o CSoftwareTexture2.o CTRTextureGouraud2.o CTRGouraud2.o CTRGouraudAlpha2.o CTRGouraudAlphaNoZ2.o CTRTextureDetailMap2.o CTRTextureGouraudAdd2.o CTRTextureGouraudAddNoZ2.o CTRTextureWire2.o CTRTextureLightMap2_Add.o CTRTextureLightMapGouraud2_M4.o IBurningShader.o CTRTextureBlend.o CTRTextureGouraudAlpha.o CTRTextureGouraudAlphaNoZ.o CDepthBuffer.o CBurningShader_Raster_Reference.o
 IRRIOOBJ = CFileList.o CFileSystem.o CLimitReadFile.o CMemoryFile.o CReadFile.o CWriteFile.o CXMLReader.o CXMLWriter.o CWADReader.o CZipReader.o CPakReader.o CNPKReader.o CTarReader.o CMountPointReader.o irrXML.o CAttributes.o lzma/LzmaDec.o
-IRROTHEROBJ = CIrrDeviceSDL.o CIrrDeviceLinux.o CIrrDeviceConsole.o CIrrDeviceStub.o CIrrDeviceWin32.o CIrrDeviceFB.o CLogger.o COSOperator.o Irrlicht.o os.o leakHunter.o
+IRROTHEROBJ = CIrrDeviceSDL.o CIrrDeviceSDL2.o CIrrDeviceLinux.o CIrrDeviceConsole.o CIrrDeviceStub.o CIrrDeviceWin32.o CIrrDeviceFB.o CLogger.o COSOperator.o Irrlicht.o os.o leakHunter.o
 IRRGUIOBJ = CGUIButton.o CGUICheckBox.o CGUIComboBox.o CGUIContextMenu.o CGUIEditBox.o CGUIEnvironment.o CGUIFileOpenDialog.o CGUIFont.o CGUIImage.o CGUIInOutFader.o CGUIListBox.o CGUIMenu.o CGUIMeshViewer.o CGUIMessageBox.o CGUIModalScreen.o CGUIScrollBar.o CGUISpinBox.o CGUISkin.o CGUIStaticText.o CGUITabControl.o CGUITable.o CGUIToolBar.o CGUIWindow.o CGUIColorSelectDialog.o CDefaultGUIElementFactory.o CGUISpriteBank.o CGUIImageList.o CGUITreeView.o
 ZLIBOBJ = zlib/adler32.o zlib/compress.o zlib/crc32.o zlib/deflate.o zlib/inffast.o zlib/inflate.o zlib/inftrees.o zlib/trees.o zlib/uncompr.o zlib/zutil.o
 JPEGLIBOBJ = jpeglib/jcapimin.o jpeglib/jcapistd.o jpeglib/jccoefct.o jpeglib/jccolor.o jpeglib/jcdctmgr.o jpeglib/jchuff.o jpeglib/jcinit.o jpeglib/jcmainct.o jpeglib/jcmarker.o jpeglib/jcmaster.o jpeglib/jcomapi.o jpeglib/jcparam.o jpeglib/jcprepct.o jpeglib/jcsample.o jpeglib/jctrans.o jpeglib/jdapimin.o jpeglib/jdapistd.o jpeglib/jdatadst.o jpeglib/jdatasrc.o jpeglib/jdcoefct.o jpeglib/jdcolor.o jpeglib/jddctmgr.o jpeglib/jdhuff.o jpeglib/jdinput.o jpeglib/jdmainct.o jpeglib/jdmarker.o jpeglib/jdmaster.o jpeglib/jdmerge.o jpeglib/jdpostct.o jpeglib/jdsample.o jpeglib/jdtrans.o jpeglib/jerror.o jpeglib/jfdctflt.o jpeglib/jfdctfst.o jpeglib/jfdctint.o jpeglib/jidctflt.o jpeglib/jidctfst.o jpeglib/jidctint.o jpeglib/jmemmgr.o jpeglib/jmemnobs.o jpeglib/jquant1.o jpeglib/jquant2.o jpeglib/jutils.o jpeglib/jcarith.o jpeglib/jdarith.o jpeglib/jaricom.o
-- 
1.8.4.2

